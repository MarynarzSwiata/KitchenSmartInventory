"""
Database models for Kitchen Smart Inventory application.

This module defines all SQLModel classes that represent database tables.
SQLModel combines SQLAlchemy (for database operations) with
Pydantic (for data validation).

Models:
- Location: Physical locations in the kitchen (e.g., Fridge, Pantry)
- Store: Shops where products can be purchased (e.g., Lidl, Mercadona)
- Product: Catalog definition of items (e.g., "Milk 3.2%", "Eggs M 10-pack")
- InventoryItem: Physical instances of products in specific locations

All models include automatic `created_at` and `updated_at` timestamps via
the `TimestampMixin` (database-level defaults and on-update behavior).
"""

from datetime import date, datetime
from typing import Optional, TypeVar, Generic
from pydantic import BaseModel
from sqlmodel import Field, SQLModel, Relationship
from sqlalchemy import Column, DateTime, func, UniqueConstraint
from sqlalchemy.ext.declarative import declared_attr


T = TypeVar("T")


class TimestampMixin:
    @declared_attr
    def created_at(cls):
        return Column(DateTime(timezone=True), server_default=func.now())

    @declared_attr
    def updated_at(cls):
        return Column(
            DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
        )


class Location(SQLModel, TimestampMixin, table=True):
    """
    Represents a physical location in the kitchen where items are stored.

    Examples: "Fridge", "Freezer", "Pantry", "Upper Cabinet"

    Includes automatic created_at / updated_at timestamps.
    """

    # Primary key - automatically generated by database
    id: Optional[int] = Field(default=None, primary_key=True)

    # Location name - indexed for fast searches
    name: str = Field(index=True)

    # Relationship to inventory items
    inventory_items: list["InventoryItem"] = Relationship(back_populates="location")


class Store(SQLModel, TimestampMixin, table=True):
    """
    Represents a store where products can be purchased.

    Examples: "Lidl", "Mercadona", "Dia", "Local Market"

    Includes automatic created_at / updated_at timestamps.
    """

    # Primary key - automatically generated by database
    id: Optional[int] = Field(default=None, primary_key=True)

    # Store name - indexed for fast searches
    name: str = Field(index=True)

    # Relationship to inventory items
    inventory_items: list["InventoryItem"] = Relationship(back_populates="store")

    # Relationship to shopping list items
    shopping_list_items: list["ShoppingListItem"] = Relationship(back_populates="store")


class Product(SQLModel, TimestampMixin, table=True):
    """
    Represents a product catalog definition (not a physical item).

    This is the "template" for items - it defines what the product IS,
    not where it is or how many we have.

    Examples:
    - name="Milk", brand="Mercadona"
    - name="Eggs M 10-pack", brand="None"

    Includes automatic created_at / updated_at timestamps.
    """

    __table_args__ = (UniqueConstraint("name", "brand", name="uq_name_brand"),)

    # Primary key - automatically generated by database
    id: Optional[int] = Field(default=None, primary_key=True)

    # Product name - indexed for fast searches (e.g., searching for "milk")
    name: str = Field(index=True)

    # Brand name - optional and indexed (e.g., filter by brand "≈Åaciate")
    brand: Optional[str] = Field(default=None, index=True)

    # Relationship to inventory items
    inventory_items: list["InventoryItem"] = Relationship(back_populates="product")

    # Relationship to shopping list items
    shopping_list_items: list["ShoppingListItem"] = Relationship(
        back_populates="product"
    )


class InventoryItem(SQLModel, TimestampMixin, table=True):
    """
    Represents a physical instance of a product in inventory.

    This is the CORE model - it connects everything together:
    - WHAT: Links to a Product (what item is this?)
    - WHERE: Links to a Location (where is it stored?)
    - FROM WHERE: Links to a Store (where was it bought? - optional)
    - HOW MUCH: quantity, price, dates

    Example:
    - Product: "Milk 3.2%"
    - Location: "Fridge"
    - Store: "Mercadona"
    - Quantity: 1.0
    - Expiration: 2025-11-15

    Includes automatic created_at / updated_at timestamps.
    """

    # Primary key - automatically generated by database
    id: Optional[int] = Field(default=None, primary_key=True)

    # Item properties
    quantity: float = Field(
        default=1.0
    )  # Allows partial items like 0.5 kg or 2.5 liters
    purchase_date: Optional[date] = Field(default=None)  # When was it bought?
    expiration_date: Optional[date] = Field(default=None)  # When does it expire?
    price: Optional[float] = Field(default=None)  # How much did it cost?

    # Foreign keys - relationships to other tables
    # These create the relational database structure

    product_id: int = Field(
        foreign_key="product.id"
    )  # REQUIRED: Every item must be a product - links to Product.id
    product: "Product" = Relationship(back_populates="inventory_items")

    location_id: int = Field(
        foreign_key="location.id"
    )  # REQUIRED: Every item must be somewhere - links to Location.id
    location: "Location" = Relationship(back_populates="inventory_items")

    store_id: Optional[int] = Field(
        default=None, foreign_key="store.id"
    )  # OPTIONAL: We might not know where it was bought - links to Store.id
    store: Optional["Store"] = Relationship(back_populates="inventory_items")


class ShoppingListItem(SQLModel, TimestampMixin, table=True):
    """
    Represents an item on the shopping list.

    This is a lightweight model for tracking what needs to be purchased:
    - WHAT: Links to a Product (what do we need to buy?)
    - WHERE: Links to a Store (where should we buy it? - optional)
    - HOW MUCH: quantity (how many/much do we need?)
    - NOTE: Optional text note for additional information

    Example:
    - Product: "Milk 3.2%"
    - Store: "Mercadona"
    - Quantity: 2.0
    - Note: "Buy the large bottle"

    Includes automatic created_at / updated_at timestamps.
    """

    # Primary key - automatically generated by database
    id: Optional[int] = Field(default=None, primary_key=True)

    # Item properties
    quantity: float = Field(default=1.0)  # How many/much to buy
    note: Optional[str] = Field(default=None, max_length=255)  # Additional notes

    # Foreign keys - relationships to other tables
    product_id: int = Field(
        foreign_key="product.id"
    )  # REQUIRED: What product to buy - links to Product.id
    product: "Product" = Relationship(back_populates="shopping_list_items")

    store_id: Optional[int] = Field(
        default=None, foreign_key="store.id"
    )  # OPTIONAL: Preferred store - links to Store.id
    store: Optional["Store"] = Relationship(back_populates="shopping_list_items")


# ============================================================================
# Response Schemas (to include timestamps in API responses)
# ============================================================================


class LocationRead(SQLModel):
    id: int
    name: str
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class StoreRead(SQLModel):
    id: int
    name: str
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class ProductRead(SQLModel):
    id: int
    name: str
    brand: Optional[str]
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class PaginatedResponse(BaseModel, Generic[T]):
    total: int
    offset: int
    limit: int
    items: list[T]


# ============================================================================
# InventoryItem API Schemas
# ============================================================================


class InventoryItemCreate(SQLModel):
    """Schema for creating a new inventory item (API input)."""

    product_id: int
    location_id: int
    store_id: Optional[int] = None
    quantity: float
    purchase_date: Optional[date] = None
    expiration_date: Optional[date] = None
    price: Optional[float] = None


class InventoryItemUpdate(SQLModel):
    """Schema for updating an inventory item (API input)."""

    product_id: Optional[int] = None
    location_id: Optional[int] = None
    store_id: Optional[int] = None
    quantity: Optional[float] = None
    purchase_date: Optional[date] = None
    expiration_date: Optional[date] = None
    price: Optional[float] = None


class InventoryItemRead(SQLModel):
    """Schema for reading an inventory item (API output, basic)."""

    id: int
    product_id: int
    location_id: int
    store_id: Optional[int]
    quantity: float
    purchase_date: Optional[date]
    expiration_date: Optional[date]
    price: Optional[float]
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class InventoryItemReadWithRelations(InventoryItemRead):
    """
    Schema for reading an inventory item with related entities
    (API output, detailed).
    """

    product: ProductRead
    location: LocationRead
    store: Optional[StoreRead] = None


# ============================================================================
# ShoppingListItem API Schemas
# ============================================================================


class ShoppingListItemCreate(SQLModel):
    """Schema for creating a new shopping list item (API input)."""

    product_id: int
    store_id: Optional[int] = None
    quantity: float
    note: Optional[str] = None


class ShoppingListItemRead(SQLModel):
    """Schema for reading a shopping list item (API output, basic)."""

    id: int
    product_id: int
    store_id: Optional[int]
    quantity: float
    note: Optional[str]
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class ShoppingListItemReadWithRelations(ShoppingListItemRead):
    """
    Schema for reading a shopping list item with related entities
    (API output, detailed).
    """

    product: ProductRead
    store: Optional[StoreRead] = None
